/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example

import java.io.File
import java.io.FileInputStream
import java.io.FileOutputStream
import java.security.SecureRandom
import java.security.KeyFactory
import java.security.PublicKey
import java.security.spec.X509EncodedKeySpec
import java.security.spec.MGF1ParameterSpec
import java.util.Base64
import java.util.Arrays
import javax.crypto.Cipher
import javax.crypto.spec.SecretKeySpec
import javax.crypto.spec.GCMParameterSpec
import javax.crypto.spec.OAEPParameterSpec
import javax.crypto.spec.PSource

fun main() {
    println("Hi")
    val key = generateKey(32)
    val iv = aesFileEncrypt(key, "gradlew", "gradlew.bin")
    if (iv != null) aesFileDecrypt(key, iv, "gradlew.bin", "gradlew.txt")
}

fun generateKey(size: Int): ByteArray {
    val k = ByteArray(size)
    SecureRandom().nextBytes(k)
    return k
}

fun isFileExists(path: String) = File(path).exists()

/**
* For small data encryption
*/
fun aesEncrypt(data: ByteArray, key: ByteArray): String {
    val iv = ByteArray(12)
    SecureRandom().nextBytes(iv)
    val cipher = Cipher.getInstance("AES/GCM/NoPadding")
    cipher.init(Cipher.ENCRYPT_MODE, SecretKeySpec(key, "AES"), GCMParameterSpec(128, iv))
    return Base64.getEncoder().encodeToString(iv+ cipher.doFinal(data))
}

/**
* Decrypt small data
*/
fun aesDecrypt(data: String, key: ByteArray): String {
    val cipherText = Base64.getDecoder().decode(data)
    val iv = Arrays.copyOfRange(cipherText, 0, 12)
    val cip = Arrays.copyOfRange(cipherText, 12, cipherText.size)
    val cipher = Cipher.getInstance("AES/GCM/NoPadding")
    cipher.init(Cipher.DECRYPT_MODE, SecretKeySpec(key, "AES"), GCMParameterSpec(128, iv))
    return cipher.doFinal(cip).decodeToString()
}

/**
* File Encryption  
* [key] AES key to encrypt  
* [file1] File to be encrypted  
* [file2] Encrypted file
* Return iv (Initialization Vector) of the Encrypted file
*/
fun aesFileEncrypt(key: ByteArray, file1: String, file2: String): ByteArray? {
    if (!isFileExists(file1)) return null
    val iv = generateKey(12)
    val cipher = Cipher.getInstance("AES/GCM/NoPadding")
    cipher.init(Cipher.ENCRYPT_MODE, SecretKeySpec(key, "AES"), GCMParameterSpec(128, iv))
    val fis = FileInputStream(file1)
    val fos = FileOutputStream(file2)
    val buff = ByteArray(1024)
    var len: Int
    while (fis.read(buff).also { len = it } != -1) {
        val chunk = cipher.update(buff, 0, len)
        if (chunk != null) fos.write(chunk)
    }
    fos.write(cipher.doFinal())
    fis.close()
    fos.close()
    return iv
}

/**
* Decrypt file  
* [key] AES Key to decrypt  
* [iv] IV for the file  
* [file1] File to be decrypted  
* [file2] Decrypted file
*/
fun aesFileDecrypt(key: ByteArray, iv: ByteArray, file1: String, file2: String) {
    if (!isFileExists(file1)) return
    val cipher = Cipher.getInstance("AES/GCM/NoPadding")
    cipher.init(Cipher.DECRYPT_MODE, SecretKeySpec(key, "AES"), GCMParameterSpec(128, iv))
    val fis = FileInputStream(file1)
    val fos = FileOutputStream(file2)
    val buff = ByteArray(1024)
    var len: Int
    while (fis.read(buff).also { len = it } != -1) {
        val chunk = cipher.update(buff, 0, len)
        if (chunk != null) fos.write(chunk)
    }
    fos.write(cipher.doFinal())
    fis.close()
    fos.close()
}

fun rsaEncrypt(data: ByteArray, key: ByteArray): String {
    val publicKey: PublicKey = KeyFactory.getInstance("RSA").generatePublic(X509EncodedKeySpec(key))
    val cipher = Cipher.getInstance("RSA/ECB/OAEPwithSHA-512andMGF1Padding")
    cipher.init(Cipher.ENCRYPT_MODE, publicKey, OAEPParameterSpec("SHA-512", "MGF1", MGF1ParameterSpec.SHA512, PSource.PSpecified.DEFAULT))
    return Base64.getEncoder().encodeToString(cipher.doFinal(data))
}